<!DOCTYPE HTML>
<HTML lang="en">

    <head >

        <script src="https://wgpu-matrix.org/dist/3.x/wgpu-matrix.min.js"></script>
        <script src="basicObjectNormals.js"></script>
       

        <script >
            
            
            class Camera 
            {
	            constructor()
                {
                    this.pos = [0, 0, -3];
                    this.rot = [0, 0, 0];
                    this.velocity = [0, 0, 0];
                    this.angVelocity = [0,0,0];
                    this.transform = new Transform();

                    this.camBuffer = m.GPU.device.createBuffer({
                        size: 80,
                        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
                    });
                  

                   
                    this.camGroup = m.GPU.device.createBindGroup({
                    label:"camera",
                    layout: m.GPU.cameraBindLayout, 
                    entries: [
                        { binding: 0, resource: { buffer: this.camBuffer } }
                    ],
                });

            }
            Move()
            {
                var tempP = [0,0,0]
                for(var i =0; i< 3;i ++)
                {
                    tempP[i] = this.pos[i];
                    tempP[i] += this.velocity[i];
                    this.rot[i] += this.angVelocity[i];
                }
                if(!this.isTrigger)
                {
                    var clear = true;
                    for(var so in m.Solid)
                    {
                        if(m.Solid[so] != this)
                        {
                            if(m.CheckCollision(tempP,this.collissionRadius,m.Solid[so].loc,m.Solid[so].collissionRadius))
                            {
                                clear = false;
                                tempP.OnPhysicalHit(m.Solid[so])
                                try
                                {
                                    m.Solid[so].OnPhysicalHit(tempP)
                                }
                                catch (error)
                                {
                                    //Assume other object has been destroyed
                                }
                            }
                        }
                    } 
                    if(clear)
                    {
                    this.pos = tempP;
                    }
                }
                else
                {
                    this.pos = tempP;
                    for(var so in m.Trigger)
                    {
                        if(m.Trigger[so] != this)
                        {
                            if(m.CheckCollision(tempP,this.collissionRadius,m.Trigger[so].loc,m.Trigger[so].collissionRadius))
                            {
                                tempP.OnTriggerHit(m.Trigger[so])
                                try
                                {
                                    m.Trigger[so].OnTriggerHit(tempP)
                                }
                                catch (error)
                                {
                                    //Assume other object has been destroyed
                                }
                            }
                        }
                    } 
                }
            }

	Update() {
		this.velocity = [0, 0, 0];

		if (m.checkKey("W")) this.velocity[2] = 0.1;
		if (m.checkKey("S")) this.velocity[2] = -0.1;
		if (m.checkKey("A")) this.velocity[0] = -0.1;
		if (m.checkKey("D")) this.velocity[0] = 0.1;
        if (m.checkKey("Q")) this.angVelocity[0] = -0.01;
		if (m.checkKey("E")) this.angVelocity[0] = 0.01;

		this.Move();
	}



	Render(passEncoder) {
		passEncoder.setBindGroup(1, this.camGroup);
		m.GPU.device.queue.writeBuffer(this.camBuffer, 0, new Float32Array(this.pos)); // position
		m.GPU.device.queue.writeBuffer(this.camBuffer, 16, new Float32Array(this.rot)); // rotation
	}
}



            class DirLight 
{
    constructor(direction, color)
    {
        this.transform = new Transform();
    
        this.direction=direction;
        this.color=color;
        this.lightIndex = m.currentDirLight;
        m.currentDirLight++;
        this.ambientLight = 1;
                
        this.dLightGroup = m.GPU.device.createBindGroup({
        label: "DirLight",
        layout: m.GPU.lightBindLayoutLocal,
        entries: [
            { binding: 0, resource: { buffer: m.GPU.lightBuffer } },
        ]
});
    }

            Update()
            {

            }	
        
            Render(commandPass)
            {
                commandPass.setBindGroup(2, this.dLightGroup); 
                const offset = 336+ this.lightIndex * 32; 
                m.GPU.device.queue.writeBuffer(m.GPU.lightBuffer,offset , new Float32Array(this.direction)); // direction 
                m.GPU.device.queue.writeBuffer(m.GPU.lightBuffer, offset + 16, new Float32Array(this.color)); // color
            }
    }


    class SpotLight 
{
    constructor(position, direction, color)
    {
        this.transform = new Transform();
        this.position=position;
        this.direction=direction;
        this.color=color;
        this.lightIndex = m.currentSpotLight;
        m.currentSpotLight++;
        this.ambientLight = 0.9;
        const dummyTexture = m.GPU.device.createTexture({
            size: [1, 1, 1],
            format: "rgba8unorm",
            usage: GPUTextureUsage.TEXTURE_BINDING
        }).createView();
                
        this.sLightGroup = m.GPU.device.createBindGroup
        ({
            label:"SpotLight",
            layout: m.GPU.lightBindLayoutLocal,
            entries: [
            { binding: 0, resource: { buffer: m.GPU.lightBuffer}},]}); 
            m.GPU.device.queue.writeBuffer(m.GPU.lightBuffer,8,new Uint32Array([m.currentSpotLight]))
            }
            Update() {
                const t = performance.now() * 0.001;
                let radius = 30.0;       
                const speed = 1.5; 
                const center = [this.direction[0], this.direction[1], this.direction[2]]     
                if (t%2 ==0)
                {
                    radius = 25;
                }
                if(t%6==0)
                {
                    radius=15;
                }
                if(t%8==0)
                {radius=30};
                
                    
       
                const x = center[0] +radius* Math.cos(t * speed+this.lightIndex);  
                const z = center[2] +radius * Math.sin(t * speed+this.lightIndex);  
                const y = center[1];                           

                this.position = [x, y, z, 1.0];

                const dir = [center[0]-x,center[1]-y,center[2]-z,1]
                const len = Math.hypot(...dir);
                this.direction = [dir[0]/len, dir[1]/len, dir[2]/len, 0.0];

                const offset = 656 + this.lightIndex * 48;  
                m.GPU.device.queue.writeBuffer(m.GPU.lightBuffer, offset, new Float32Array(this.position));
                m.GPU.device.queue.writeBuffer(m.GPU.lightBuffer, offset + 16, new Float32Array(this.direction));
                m.GPU.device.queue.writeBuffer(m.GPU.lightBuffer, offset + 32, new Float32Array(this.color));
            }

            Render(commandPass)
            {
                commandPass.setBindGroup(2, this.sLightGroup); 
                const offset = 656 + this.lightIndex * 48; 
                // match buffer layout 
                m.GPU.device.queue.writeBuffer(m.GPU.lightBuffer, 656 + this.lightIndex * 48, new Float32Array(this.position)); 
                m.GPU.device.queue.writeBuffer(m.GPU.lightBuffer, 656 + this.lightIndex * 48 + 16, new Float32Array(this.direction)); // direction 
                m.GPU.device.queue.writeBuffer(m.GPU.lightBuffer, 656 + this.lightIndex * 48 + 32, new Float32Array(this.color)); // color
            }
    }
    

class main
		{	
			constructor()
			{
                this.material = 50.0;
                this.Visual = [];
                this.Solid = [];
                this.Trigger = [];
                this.ObjectCounter = 0;			
                this.GPU = new WebGPU();
                this.Keys = [];
                this.maxPointLights = 10;
                this.currentPointLight = 0;
                this.currentDirLight = 0;
                this.currentSpotLight=0;
                
                
			}
			
			UpdateAll()
			{
                
                this.GPU.camera.Update();
			
			}
			
			RenderAll()
			{
			    this.GPU.RenderAll();
			}
			CheckCollision(loc1,rad1,loc2, rad2)
			{
				
				return false;
			}
			
			checkKey(k)
			{
				if(k in this.Keys)
				{
					return this.Keys[k]
				}
				return false
			}
			
			KeyDown(event)
			{
				this.Keys[String.fromCharCode(event.keyCode)] = true;			
			}
			
			KeyUp(event)
			{
				this.Keys[String.fromCharCode(event.keyCode)] = false;
			}
			
			MouseClick(event)
			{
				var rect = canvas.getBoundingClientRect();
				var realX = event.clientX - rect.left;
				var realY = event.clientY - rect.top;
				var x = -1 + 2*realX/myCanvas.width;
				var y = -1 + 2*(myCanvas.height - realY)/myCanvas.height;
			}
			static keyD(event)
			{
                console.log("key pressed"+event)
				m.KeyDown(event);
			}
			static keyU(event)
			{
				m.KeyUp(event);
			}

			static mouseH(event)
			{
				m.MouseClick(event);
			}
			
			static MainLoop()
			{
				
				m.UpdateAll();
				m.RenderAll();
				requestAnimationFrame(main.MainLoop);
			}

		}
		
class WebGPU {
    constructor() {
        this.isReady = false;
        this.SetUpGPU().then(() => { this.SlowStart(); });
    }

    async SlowStart() {
        
        this.camera = new Camera();
        this.pointL = new PointLight([0, -2, 0, 1], [1, 0.5, 0.1]);
        this.pointL2 = new PointLight([15, -2, 0, 1], [0.2, 0.6, 0]);
        this.pointL3 = new PointLight([-15, -2, 0, 1], [0.4, 0.7, 0.1]);
        this.pointL4 = new PointLight([0, -3, -10, 1], [1, 0.6, 0.1]);
        this.pointL5 = new PointLight([15, -3, -10, 1], [0.2, 0, 0]);
        this.pointL6 = new PointLight([-15, -3, -10, 1], [0.4, 0.7, 0.1]);
        this.pointL7 = new PointLight([-10, 0, 2, 1], [1, 1, 0]);
        this.pointL8 = new PointLight([-15, 13, 4, 1], [0.1, 0.7, 0.1]);
        this.pointL9 = new PointLight([-7, 3, 2, 1], [0.3, 0.5, 0.1]);
        this.pointL10 = new PointLight([5, 1, 1, 1], [0, 1, 0.5]);

        this.dirL = new DirLight([1, 1, 1, 0], [1, 0, 0, 1]);  
        const { mat4, vec3, vec4 } = wgpuMatrix;
        const identityMat = mat4.create();  

        const materials0 = await new ColorLoad().load("bag.mtl");
        const materials1 = await new ColorLoad().load("table.mtl");
        const materials2 = await new ColorLoad().load("markBag.mtl");
        const materials3 = await new ColorLoad().load("shoes.mtl");
        const materials4 = await new ColorLoad().load("glasses2.mtl");
        const materials5 = await new ColorLoad().load("shoes2.mtl");
        const materials6 = await new ColorLoad().load("sunGlasses.mtl");
        const matMirror = await new ColorLoad().load("mirror.mtl");
        const matFloor = await new ColorLoad().load("floor.mtl");

        async function loadOBJWithMaterials(objFile, mat, textureFile = null) 
        {
            const objText = await fetch(objFile).then(r => r.text());
            const objLoader = new OBJLoad(objText);
            const parsedData = objLoader.parse(mat);


            let texture = null;
            if (textureFile) {
                texture = await DiffuseTextureLoad.loadTexture(textureFile);
            }

            return { ...parsedData, texture };
        }


        const obj0 = await loadOBJWithMaterials("bag.obj", materials0, "silver.png");

        const obj1 = await loadOBJWithMaterials("table.obj", materials1,"plastic.png");
        const obj2 = await loadOBJWithMaterials("markBag.obj", materials2,"bagTexture.png");
        const obj3 = await loadOBJWithMaterials("shoes.obj", materials3,"pinkShoes.png");
        const obj4 = await loadOBJWithMaterials("glasses2.obj", materials4,"goldGlasses.png");
        const obj5 = await loadOBJWithMaterials("shoes2.obj", materials5,"silver.png");
        const obj6 = await loadOBJWithMaterials("sunGlasses.obj", materials6,"purpleGlasses.png");
        const mirror = await loadOBJWithMaterials("mirror.obj", matMirror,"mirrortext.png");
        const objFloor = await loadOBJWithMaterials("floor.obj", matFloor,"floortext.png");


        const normalMapTable = await TextureLoad.loadTexture("plastic.png");
        const normalMapBag = await TextureLoad.loadTexture("snakeSkin.png");
        const normalDMapBag = await TextureLoad.loadTexture("bag1.png");
        const normalMapShoes = await TextureLoad.loadTexture("canvas.png");
        const normalMapMirror = await TextureLoad.loadTexture("table.png");
        const normalMapFloor = await TextureLoad.loadTexture("markBag.png");

        const text0 = await DiffuseTextureLoad.loadTexture("silver.png");
        const text1 = await DiffuseTextureLoad.loadTexture("bagTexture.png");
       
        const text3 = await DiffuseTextureLoad.loadTexture("goldGlasses.png");
        const text4 = await DiffuseTextureLoad.loadTexture("pinkShoes.png");
        const text5 = await DiffuseTextureLoad.loadTexture("plastic.png");
        const text6 = await DiffuseTextureLoad.loadTexture("purpleGlasses.png");
        const text7 = await DiffuseTextureLoad.loadTexture("mirrortext.png");
        const text8 = await DiffuseTextureLoad.loadTexture("floortext.png");


        this.shape0 = new BasicShape(obj0,[-1.5,3.5,4], [1,1.5,1], [1,1,1], materials0, normalDMapBag, text0);
         


        this.table1 = new BasicShape(obj1, [0,-5,0], [0,0,0], [5,5,5], materials1, normalMapTable,text8);
        this.table2 = new BasicShape(obj1, [15,-5,0], [0,0,0], [5,5,5], materials1, normalMapTable,text8);
        this.table3 = new BasicShape(obj1, [-15,-5,0], [0,0,0], [5,5,5], materials1, normalMapTable,text8);
        this.table4 = new BasicShape(obj1, [0,-6,-10], [0,0,0], [5,5,5], materials1, normalMapTable,text8);
        this.table5 = new BasicShape(obj1, [15,-6,-10], [0,0,0], [5,5,5], materials1, normalMapTable,text8);
        this.table6 = new BasicShape(obj1, [-15,-6,-10], [0,0,0], [5,5,5], materials1, normalMapTable,text8);

        this.shape2 = new BasicShape(obj2, [15,1,0], [0,0,0], [1,1,1], materials2, normalMapBag,text1);
        this.shape3 = new BasicShape(obj3, [-15,-0.1,0], [0,0,0], [1,1,1], materials3, normalMapShoes,text4);
        this.shape4 = new BasicShape(obj4, [0,0,-10], [0,2.5,0], [1,1,1], materials4, normalMapShoes,text3); 
        this.shape5 = new BasicShape(obj5, [-14,-1,-7], [0,2,0], [1.5,1.5,1.5], materials5, normalMapShoes,text0);
        this.shape6 = new BasicShape(obj6, [15,-0.5,-10], [0,0,0], [0.15,0.15,0.15], materials6, normalMapShoes,text6);

        this.floor = new BasicShape(objFloor, [0,-10,0], [0,0,0], [10,10,10], matFloor, normalMapFloor,text8);
        this.wall = new BasicShape(objFloor, [0,50,-20], [0,0,0], [10,10,10], matFloor, normalMapFloor,text8);

        this.mirror = new BasicShape(mirror, [-25,-2,0], [-1.8,-1.3,0.3], [1,0,6], matMirror, normalMapMirror,text7);
        this.mirror2 = new BasicShape(mirror, [35,30,0], [2,1.2,0.3], [1,0,7], matMirror, normalMapMirror,text7);

        
       

        this.spotL = new SpotLight([-5, 5, 0, 1], [0, -1, 0, 1, 1], [1, 0, 0, 1]);
        this.spotL2 = new SpotLight([15, 5, 0, 1], [15, 1, 0, 1], [0.3, 0, 1, 1]);
        this.spotL3 = new SpotLight([-28, 5, -12, 1], [-28, 0, -12, 1], [0, 0, 1, 1]);
        this.spotL4 = new SpotLight([5, 5, -12, 1], [5, 0, -10, 1], [0, 0.5, 1, 1]);
        this.spotL5 = new SpotLight([20, 5, -10, 1], [0, 1, 0, 1, 1], [1, 0.4, 0, 1]);
        this.spotL6 = new SpotLight([-17, 5, -15, 1], [-17, 1, -8, 1], [1, 1, 0, 1]);

        requestAnimationFrame(main.MainLoop);
        this.RenderAll();
    }

    UpdateAll() {
        
    }

    async SetUpGPU() {
        this.adapter = await navigator.gpu.requestAdapter();
        if (!this.adapter) throw new Error("No appropriate GPUAdapter found.");

        this.device = await this.adapter.requestDevice();
        if (!this.device) throw new Error("Need a browser that supports WebGPU.");

        console.log("WebGPU device found!");
        this.canvas = document.querySelector('canvas');
        this.context = this.canvas.getContext('webgpu');
        this.presentationFormat = navigator.gpu.getPreferredCanvasFormat();
        this.context.configure({ device: this.device, format: this.presentationFormat });

        this.depthTexture = this.device.createTexture({
            size: { width: this.canvas.width, height: this.canvas.height, depthOrArrayLayers: 1 },
            format: "depth24plus",
            usage: GPUTextureUsage.RENDER_ATTACHMENT,
        });
        this.depthTextureView = this.depthTexture.createView();


        this.cellShaderModule = this.device.createShaderModule({ label: "Simple shader", code:
        `
        
        struct UniformCordinates 
        {
            matrix: mat4x4<f32>,
        };

        @group(0) @binding(0) var<uniform> myCords: UniformCordinates;
        @group(0) @binding(1) var normalMap: texture_2d<f32>;
        @group(0) @binding(2) var sampler0: sampler;
        @group(0) @binding(3) var diffuseMap: texture_2d<f32>;

       
        struct DirectionalLight { direction: vec4<f32>, color: vec4<f32> };
        struct PointLight { position: vec4<f32>, color: vec4<f32> };
        struct SpotLight { position: vec4<f32>, direction: vec4<f32>, color: vec4<f32> };

        struct ComplexLightSystem {
            numPoint: u32,
            numDir: u32,
            numSpot: u32,
            ambient: f32, 
            pointLights: array<PointLight, 10>,
            dirLights: array<DirectionalLight, 10>,
            spotLights: array<SpotLight, 10>,
        };

        @group(2) @binding(0) var<uniform> complexLight: ComplexLightSystem;

        struct CameraInfo { translation: vec3<f32>, rotation: vec3<f32> };
        @group(1) @binding(0) var<uniform> myCam: CameraInfo;

        struct ColorVarying {
            @builtin(position) position: vec4<f32>,
            @location(0) color: vec3<f32>,
            @location(1) normal: vec3<f32>,
            @location(2) worldPos: vec3<f32>,
            @location(3) vectorToCam: vec3<f32>,
            @location(4) T: vec3<f32>,
            @location(5) B: vec3<f32>,
            @location(6) uv: vec2<f32>,
        };

        @vertex
        fn vertexMain(
            @location(0) pos: vec3<f32>, 
            @location(1) col: vec3<f32>, 
            @location(2) normal: vec3<f32>, 
            @location(3) tangent: vec4<f32>,
            @location(4) uv: vec2<f32>,
        ) -> ColorVarying {
            var out: ColorVarying;

            // Apply model matrix
            let worldPos4 = myCords.matrix * vec4<f32>(pos, 1.0);
            out.worldPos = worldPos4.xyz;

            // Transform normal and tangent to world space
            let N = normalize((myCords.matrix * vec4<f32>(normal, 0.0)).xyz);
            let T = normalize((myCords.matrix * vec4<f32>(tangent.xyz, 0.0)).xyz);
            let B = cross(N, T) * tangent.w;

            out.normal = N;
            out.T = T;
            out.B = B;

            out.vectorToCam = normalize(myCam.translation - out.worldPos);
            out.color = col;
            out.uv = uv;

            // Apply camera transform (view)
            var viewPos = vec4<f32>(out.worldPos, 1.0) - vec4<f32>(myCam.translation, 0.0);
            // For simplicity, only Y-axis rotation
            let c = cos(-myCam.rotation.y);
            let s = sin(-myCam.rotation.y);
            viewPos = vec4<f32>(
                c * viewPos.x + s * viewPos.z,
                viewPos.y,
                -s * viewPos.x + c * viewPos.z,
                1.0
            );

            // Perspective projection
            let n: f32 = 0.1;
            let f: f32 = 5000.0;
            let aspect: f32 = 1.0;
            let fov: f32 = 1.0;
            let persp = mat4x4<f32>(
                vec4<f32>(1.0/(aspect*fov), 0.0, 0.0, 0.0),
                vec4<f32>(0.0, 1.0/fov, 0.0, 0.0),
                vec4<f32>(0.0, 0.0, (f+n)/(f-n), 1.0),
                vec4<f32>(0.0, 0.0, -2.0*f*n/(f-n), 0.0)
            );

            out.position = persp * viewPos;
            return out;
        }
       


        @fragment
fn fragmentMain(fsInput: ColorVarying) -> @location(0) vec4<f32> {
    let diffuseColor = textureSample(diffuseMap, sampler0, fsInput.uv);

    let uv = fsInput.worldPos.xz * 0.1;
    let nSample = textureSample(normalMap, sampler0, uv).xyz;
    let nTangent = normalize(nSample * 2.0 - 1.0);

    let N = normalize(fsInput.normal);
    let T = normalize(fsInput.T);
    let B = normalize(fsInput.B);
    let tbn = mat3x3<f32>(T, B, N);
    let N_final = normalize(tbn * nTangent);

    var colorOut = diffuseColor.rgb * complexLight.ambient+0.3; 

    // Directional lights
    for(var i=0u; i<min(complexLight.numDir,10u); i++) {
        let dirLight = complexLight.dirLights[i];
        let L = normalize(-dirLight.direction.xyz);
        let diff = max(dot(N_final, L), 0.0);
        colorOut += diffuseColor.rgb * dirLight.color.xyz * diff;
    }

    // Point lights
    for(var i=0u; i<min(complexLight.numPoint,10u); i++) {
        let pl = complexLight.pointLights[i];
        let L = normalize(pl.position.xyz - fsInput.worldPos);
        let dist = length(pl.position.xyz - fsInput.worldPos);
        let diff = max(dot(N_final, L), 0.0) / (1.0 + dist);
        colorOut += diffuseColor.rgb * pl.color.xyz * diff;
    }

    // Spot lights
    for(var i=0u; i<min(complexLight.numSpot,10u); i++) {
        let sl = complexLight.spotLights[i];
        let L = normalize(sl.position.xyz - fsInput.worldPos);
        let focus = dot(L, normalize(-sl.direction.xyz));
        if(focus >= 0.9) {
            let diff = max(dot(N_final, L), 0.0);
            colorOut += diffuseColor.rgb * sl.color.xyz * diff;
        }
    }

    return vec4<f32>(colorOut, 1.0);
}

`
            
  });
           
this.vertexBufferLayout = {
    arrayStride: 4 * 15, // 15 floats per vertex
    attributes: [
        { shaderLocation: 0, offset: 0, format: "float32x3" }, // position
        { shaderLocation: 1, offset: 3*4, format: "float32x3" }, // color
        { shaderLocation: 2, offset: 6*4, format: "float32x3" }, // normal
        { shaderLocation: 3, offset: 9*4, format: "float32x4" }, // tangent
        { shaderLocation: 4, offset: 13*4, format: "float32x2" } // uv
    ]
};
this.cameraBindLayout=this.device.createBindGroupLayout({
    label:'camera',
    entries:[{binding: 0,
        visibility: GPUShaderStage.VERTEX,
        buffer: { type: "uniform" }}]
});
this.LightBindLayout=this.device.createBindGroupLayout({
    entries: [{
        label:'light',
        binding: 0,
        visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX,
        buffer: { type: "uniform" }
    }]
});
this.objectBindLayout=this.device.createBindGroupLayout({
    label:'objects',
    entries: [ 
        {   binding: 0,
            visibility: GPUShaderStage.VERTEX,
            buffer: { type: "uniform" }},
        {
            binding: 1,
            visibility: GPUShaderStage.FRAGMENT,
            texture: {}
        },
        {
            binding: 2,
            visibility: GPUShaderStage.FRAGMENT,
            sampler: {}
        },
         {  binding: 3,
            visibility: 
            GPUShaderStage.FRAGMENT, 
            texture: {} } 
    ]
});


const CAMERA_BUFFER_SIZE = 32; 
const SHAPE_MATRIX_SIZE = 64; 
const LIGHT_BUFFER_SIZE = 1152; 

// Create uniform buffers
this.DUMMYuniformBuffer = this.device.createBuffer({ 
    size: SHAPE_MATRIX_SIZE, 
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST 
});

this.cameraBuffer = this.device.createBuffer({
    size: CAMERA_BUFFER_SIZE,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
});

this.lightBuffer = this.device.createBuffer({
    size: LIGHT_BUFFER_SIZE,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
});
this.defaultSampler = this.device.createSampler({ magFilter: "linear", minFilter: "linear" });


this.objectBindLayoutLocal = this.objectBindLayout;
this.cameraBindLayoutLocal = this.cameraBindLayout;
this.lightBindLayoutLocal = this.LightBindLayout;

this.BumpPipilineLayout = this.device.createPipelineLayout({
    bindGroupLayouts:[this.objectBindLayout, 
    this.cameraBindLayout, 
    this.LightBindLayout],
});


this.pipeline = this.device.createRenderPipeline({
    label: "Simple Pipeline",
    layout: this.BumpPipilineLayout,
    vertex: {
        module: this.cellShaderModule,
        entryPoint: "vertexMain",
        buffers: [this.vertexBufferLayout]
    },
    fragment: {
        module: this.cellShaderModule,
        entryPoint: "fragmentMain",
        targets: [{ format: this.presentationFormat }]
    },
    primitive: {
        topology: "triangle-list",
        cullMode: "none"
    },
    depthStencil: {
        format: "depth24plus",
        depthWriteEnabled: true,
        depthCompare: "less"
    }
});

console.log("Created Rendering Pipeline");
this.isReady = true;

    }
            RenderAll()
			{	
                this.spotL.Update();
                this.spotL2.Update();
                this.spotL3.Update();
                this.spotL4.Update();
                this.spotL5.Update();
                this.spotL6.Update();
			
				this.encoder = this.device.createCommandEncoder();
				this.commandPass =  this.encoder.beginRenderPass
				({
					colorAttachments: 
					[{
						view: this.context.getCurrentTexture().createView(),
						loadOp: "clear",
						clearValue: { r: 0, g: 0, b: 0, a: 1 }, 
						storeOp: "store",
					}],
                depthStencilAttachment: {
                    view: this.depthTextureView,
                    depthClearValue: 1.0,  
                    depthLoadOp: "clear",
                    depthStoreOp: "store",
                },
				
				});
				
				
				this.commandPass.setPipeline(this.pipeline)	
                this.camera.Render(this.commandPass);

                this.pointL.Render(this.commandPass);
                this.dirL.Render(this.commandPass);

                this.pointL2.Render(this.commandPass);
                this.pointL3.Render(this.commandPass);
                this.pointL4.Render(this.commandPass);
                this.pointL5.Render(this.commandPass);
                this.pointL6.Render(this.commandPass);
                this.pointL7.Render(this.commandPass);
                this.pointL8.Render(this.commandPass);
                this.pointL9.Render(this.commandPass);
                this.pointL10.Render(this.commandPass);
                

                this.spotL.Render(this.commandPass);
                this.spotL2.Render(this.commandPass);
                this.spotL3.Render(this.commandPass);
                this.spotL4.Render(this.commandPass);
                this.spotL5.Render(this.commandPass);
                this.spotL6.Render(this.commandPass);

                this.mirror.Render(this.commandPass);
                this.mirror2.Render(this.commandPass);
                //this.shape0.Render(this.commandPass);

                this.table1.Render(this.commandPass);
                this.table2.Render(this.commandPass);
                this.table3.Render(this.commandPass);
                this.table4.Render(this.commandPass);
                this.table5.Render(this.commandPass);
                this.table6.Render(this.commandPass);


                 this.shape2.Render(this.commandPass);
                this.shape3.Render(this.commandPass);
                this.shape4.Render(this.commandPass);
                this.shape5.Render(this.commandPass);
                this.shape6.Render(this.commandPass);
                this.floor.Render(this.commandPass);
                this.wall.Render(this.commandPass);
                		

                

                this.shape2.Render(this.commandPass);
                this.shape0.Render(this.commandPass);
                
				this.commandPass.end();
				this.device.queue.submit([this.encoder.finish()]);
			}
			
			
		}
 
        


	

        </script>
        <body style="padding: 15px; background-color: black; display: flex; justify-content: center;">

		<HEADER>
		
		</HEADER>
		
		<CANVAS id="myCanvas" width=1280 height=720 style = "border: 1px solid #000;background-color: #000; ">
			Your browser does not support canvas.
		</CANVAS>
		
		
		
		
		<SCRIPT >
	
			var canvas = document.getElementById("myCanvas");
		
			m = new main();
			window.onkeydown = main.keyD;

			window.onkeyup = main.keyU;
			canvas.addEventListener("click",main.mouseH);
			
			
			//requestAnimationFrame(main.MainLoop);	
			
		</SCRIPT>
    </head>
</HTML>